# design patterns [设计模式]

## 创建型模式

### Factory Method

**将类的初始化延迟到子类。**

本质:
- 父类定义创建接口。
- 子类实现创建接口，返回需要的功能类实例。不同的子类返回各自需要的类实例。

实现:
- 父类是否提供缺省实现
- 参数化工厂方法。使用时通过显式输入参数选择需要生成的类。子类继承父类的实现并可扩展。
- 对于类可以作为对象的语言，这一直接将目标类作为类变量。
- 注意命名，显式指出是否使用了*工厂方法*

### Builder

**对象的构建和表现分离。**

变化点
- 一个由许多不同部件构成的整体，需要对不同的部件做多种不同的转化。

本质
- 定义一个抽象基类，每个部件使用相应的接口。

### Abstract Factory

对工厂函数进行抽象。

抽象工厂定义所有接口。

子类负责实现具体的功能。

- 变化点
**许多类需要支持具有不同表现的相同功能。**

### Prototype

对于python来说，就是将类作为一个类变量，之后根据类变量生产实例。

### Singleton

单例模式，某一个类只能拥有一个实例。

## 结构型模式

### Adapter

包装器，已有类的接口不符合需求。对旧有类做一层包装。
- 类的适配器，使用多重继承实现。
- 对象的适配器，使用对象组合实现。

### Bridge

桥接，**抽象与实现分离**。

变化点
- 同时有多个抽象和多种实现方式。并且抽象和实现可以灵活的切换。

实现
- 对于python还是直接将类对象，作为类变量;当有多个实现时，可以在抽象层中增加工厂方法获取指定的实现.

感觉类似这样：

Abstract A \                      / Implement_1
Abstract B -  Abstract - Implement - Implement_2
Abstract C /                      \ Implement_3

### Composite

组合模式。**对单个对象和组合对象的使用具有一致性。**

关键点
- 子部件与父部件拥有相同的接口

实现
- 子部件中需要保留父部件的引用
- 需要考虑父部件中子部件的存储方式
- 最大化容器的接口，并提供缺省功能。

### Decorator(装饰器)

动态的给一个对象增加一些功能。相较与类继承更加的灵活。

关键点:
- **装饰器对象与被装饰对象需要有完全相同的接口**。可以定义一个基类，装饰器和被装饰器都继承至基类。而对于数量较少的装饰，可以不定义基类，而仅仅将数据转发给被装饰对象。
- 实现时装饰器对象中需要维持一个被装饰对象。
- 当被装饰对象原本就十分庞大时，使用`decorator`的代价太大，可以使用`strategy`模式。

### Facade(外观)

定义一个高层接口，简化对子系统的调用。

### FlyWeight（共享对象）

使用共享对象，节省内存资源。

关键点：
- 对**种类有限**但**实际数量很大**的数据进行建模。
- 重点区分**内部状态**和**外部状态**。内部状态是可以共享的，而外部状态是不可共享的。
- 对共享池进行建模
- 创建获取flyweight对象的工厂方法。

### Proxy（代理模式）

对其他对象做一层封装，控制对该对象的访问。

## 行为模式

### Chain Of Responsibility(职责链)

将对象链接起来构成一条链，将请求延链条传递直到有一个对象将其处理。解耦**发送者**和**接受者**之间的关系。

变化点：请求的发送者不确定接受者。

TODO: 感觉想不到合适的使用场景，先这样吧。
- 请求链如何合理的构建？

### Command(命令模式)

**将一个请求封装为一个对象**

要点：
- `Invoker`接受`Command`实例，并在内部维持。`Invoker`仅仅调用command暴露的公用接口。
- `Command`实例中维持`Receiver`实例。
- 每个`Command`实例可能一次调用多个`receiver`方法。

`command`模式的实现是建立在`Receiver`拥有合理的公共接口的基础上的，不然所有`Receiver`都需要对应一个`command`。

我之前对`command`模式的理解是：简单的将需要执行的命令和数据通过结构体的形式传递给`receiver`，`receiver`通过解析结构体获取`方法标识`和`数据`，通过方法标识寻找相应的方法，并将数据作为参数调用方法。



## 体会

使用设计模式的主要目的是为了**应对变化**。不同的功能有不同的表现，但他们的根本运行逻辑有一套通用的流程。将通用的逻辑抽象出来。每次实现不同的功能时，不必完全从头开发而仅需要关注功能的不同点即可。

判断自己是否应该使用设计模式？应该使用那种设计模式？这些问题的根本都在于需求中变化的点在哪里，有多少。

一句话，**对变化封装**。
