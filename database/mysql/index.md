# mysql base

- [x] 3. 服务器性能剖析
- [x] 4. schema于数据类型优化
5. 索引
6. 查询数据优化
7. mysql高级特性
8. 优化服务器配置
14. 应用程缓存


## 逻辑架构

```puml

```

## 不同存储引擎的特性
- InnoDB
- MyISAM

95%的情况下都选择InnoDB

## mysql基准测试

sysbench

## 服务性能剖析

- 分析慢查询日志
  - `pt-query-digest`工具
- 剖析单条查询
  - 使用`show profile`
  - 使用`show status`
  - `Performance Schema`
    - 书上不是很推荐，应为写书的时候，该特性还不完善，不知道现在怎么样了
- 确认时单条查询问题还是服务器问题
  - `show global status`每秒获取服务器状态
  - `show processlist`获取线程状态

## 选择优化的数据结构


### 整数类型
- tinyint/smallint/mediumint/int/bigint，分别使用8, 16, 24, 32, 64位存储空间，可以存储的值的范围从`-2 ** (n-1)`到`2 ** (n-1) - 1`

### Blob和Text类型
- blob和text被作为单独的对象进行存储。当blob和text值太大时，InnoDB会使用专门的"外部"存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值。
- 
 
### 缓存表和汇总表

缓存表: 将主表的部分信息写入缓存表中，可以针对特殊查询，创建索引或者选择合适的存储引擎

汇总表: 保存从主表中聚合而来的结果数据

### 物化视图

物化视图实际上时预先计算并存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

### 加快alter table操作的数据

mysql执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这种方式在数据量很大，而且存在很多索引的情况下需要花费很长时间。

而且`alter table`操作将导致mysql服务中断。

比较常用的办法有两个
1. 在一台不提供服务的机器上执行alter操作，之后于提供服务的主库进行切换
2. 新建一张和原表相同的表，在该表上进行操作。之后通过重命名和删表交换两张表

## 创建高性能的索引

- mysql中的最左前缀列
- 注意使用orm时orm不会生成适合索引的查询

### mysql中索引的类型
InnoDB使用的是B+Tree

- B-Tree索引
  - B-Tree按顺序存储，适合查找范围数据，并且可以通过索引的字段排序
  - 使用B-Tree的限制(*最左前缀*)
    - 如果不按照索引的最左列开始查找，则无法使用索引
    - 查找时不能跳过索引的列
    - 如果查询中有某个范围查询，则其右边所有列都无法使用索引优化查找。`IN`并不属于范围查询
- 哈希索引
  - 对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
  - mysql中只有Memory引擎支持hash索引
    - 相同hash值的不同数据，通过链表进行存储

  - 哈希索引的限制
    - 哈希索引并不是按照索引值进行排序的，所以无法用于排序
    - 不支持部分索引的匹配查找，因为哈希索引始终使用哈希列的全部内容来计算哈希值
    - 只支持等值比较包括（=，in，<=>), 不支持任务范围查询
    - 访问哈希索引的数据非常快，除非存在很多哈希冲突（不同的索引列却有相同的哈希值）。当出现哈希冲突时，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有复合条件的行。
    - 如果哈希冲突很多的话，维护索引的代价也会变高。例如删除一行数据时，需要遍历链表的每一项，进行比较。冲突越多，代价越大。
- 空间数据索引(R-Tree)
  - MyISAM表支持空间索引，一般用来作为地理数据存储。
  - 与B-Tree不同，支持任意维度的组合查询
- 全文索引
  - 通过文本的关键词进行查找，而不是直接比较索引中的值。

### 高性能的索引策略
#### 独立的列

索引列不能是表达式的一部分，也不能是函数的参数

#### 前缀索引和索引选择性

使用索引时最理想的情况是，数据的索引不出现重复，这种情况下索引的性能最好。

这里引入*选择性*的概念：索引的选择性是指，不重复的索引值和数据表的记录总树(T)的比值，范围从(1/T - 1)之间。索引的选择性越高查询效率越高。

对于`BLOB`、`TEXT`、`较长的VARCHAR列`，避免使用较长的列作为索引，必须使用**前缀索引**，即以列的部分前缀作为索引。使用前缀索引时需要选择足够长的前缀以保证较高的选择性，同时又不能太长（以节约空间）。

不过前缀索引之后，无法使用根据该索引使用`group by`和`order by`，也无法使用覆盖扫描了。

##### 前缀索引的长度选择
1. 统计不同索引前缀长度，对应的数量。并于完整长度的索引列的聚合数量进行比较。如果数量相近，则表明长度合适。
2. 针对不同的前缀长度，分别计算选择性的值，进行比较。不过这种方式存在数据分布不均衡的隐患。所以还有使用方法1进行核查。

#### 多列索引

为表中的每个列建立索引，并不能提升查询的数据。

mysql对使用多个单列索引的情况，会使用`索引合并`的策略。但索引合并策略的使用，也表明表上的索引创建的有问题，索引合并策略应当被避免。

#### 选择合适的索引列顺序

当创建一个多列索引时，对于多列索引的顺序选择。可以通过每列的选择性来判断。选择性越高的列，放在越前面。

#### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。

当表中有聚簇索引时，它的数据行实际上存放在索引的叶子页中。而对非聚簇索引中叶子页存放的是指向数据行的指针。所以一张表只能有一个聚簇索引。

mysql InnoDB主键索引是聚簇索引

使用聚簇索引，在插入数据时最好避免随机(不连续且值的分布范围非常大)的情况，特别是对于I/O密集型应用。

例如从性能的角度考虑，使用uuid作为聚簇索引会很糟糕：它会使聚簇索引的插入变得完全随机，导致大量的随机I/O，同时照成大量的页分裂；而由于大量的页分裂会导致数据存在碎片。

#### 覆盖索引

如果一个索引包含所有需要查询的字段的值，则该索引被称为覆盖索引

覆盖索引必须要存储索引的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以mysql只能使用B-Tree索引覆盖索引。

使用覆盖索引简单点理解就是，**完全通过索引获取所需的数据，减少对数据行的直接访问，从而提升查询的性能。**

**延迟关联**: 通过索引快速定位需要的最简数据(例如主键id)，之后通过join的方式获取其他数据。

#### 使用索引扫描来做排序

mysql有两种排序方式: 通过索引排序; 文件排序

*如果EXPLAN出来的Extra列的值没有出现`filesort`，说明mysql使用索引扫描来做排序*


使用索引排序的限制条件:
1. 只有当索引的列顺序和`order by`子句的顺序完全一致，并且所有列的排序方向（正序和倒序）都一样时，mysql才能够使用索引来对结果做排序。
  - 8.0版本版本的支持正序和倒序的混合
2. 如果查询需要关联多张表，则只有当`order by`引用的字段全部为第一个表时，才能够使用索引做排序。
3. order by同样遵循最左前缀的要求

#### 压缩(前缀压缩)索引

压缩索引仅在`MyISAM`中使用。

MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，将这部分存储起来即可。

压缩索引的*优点*是索引体积更小，更多的索引可以放入内存中，从而提升性能。

压缩索引的*缺点*是由于使用更少的空间，导致某些操作可能变慢。因为每个值的压缩前缀都依赖于前面的值，所以MyISAM查找时无法在索引快使用二分查找而只能从头开始查询。

#### 冗余和重复索引

mysql中的`唯一约束`和`主键约束`都是通过索引来实现的。

应当消除表中索引的重复和冗余，不过扩展和删除索引时，需要仔细检查计划中的索引变更。

[common_schema](http://code.google.com/p/common-schema/)

#### 索引与锁

InnoDB会对访问的行加锁，通过索引仅获取需要的行，仅对最少的行加锁，才能达到最优的性能。

### 索引使用的注意事项

支持多种过滤条件
- 对于索引中存在但查询条件中不存的行可以使用`IN`来规避
- 将使用范围查询的行，尽量放在索引靠后的位置
- 对索引的优化并不能仅着眼于索引，还需修改已经存在的sql中的问题。在优化查询和索引中找到最佳的平衡
- 优化索引时可以从*选择性*的角度入手

避免多个范围条件
- 根据最左前缀规则，范围条件之后的列无法使用索引

### 维护索引和表

`OPTIMIZE TABLE`

## 参考

[B+Tree in InnoDB](https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb)
