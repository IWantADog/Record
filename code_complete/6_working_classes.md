# 6 Working Classes

## 良好的类接口

好的抽象
- 明确类所实现的抽象是什么
- 类接口应该展示一致的抽象层次（单一抽象层次）
- 把不相关的信息转移到其他类中（单一职权原则）
- 尽可能让接口可编程，而不是表达语义
  
  对于出现接口间顺序依赖的情况，即`接口A`必须在`接口B`后调用，不然`接口B`会报错的情况。
  
  但在实际调用时仅从接口语义无法获取完整信息。即使存在接口注释，依然存在忽略的情况。
  
  对于这样的情况，可以使用`assert`在代码运行时及时报错，并增加详细的报错信息。
- 同时考虑抽象性和内聚性

好的封装
- 尽可能限制类和成员的可访问性
- 不公开暴露成员属性
  > 这点想要做彻底可太难了
- 避免把私用的实现细节放入类的接口中（TODO: 感觉理解起来有点模糊）
- 不要对类的使用者做出假设
- 避免使用友元类
  - 对于动态语言而言，这条应该不是很适用
- **让阅读代码比编写代码更方便**
- 格外注意避免从语义上破坏封装性

## 有关设计和实现的问题

组合关系`has a`
- 善用组合
- 控制类中数据成员的个数（5-9）

继承关系`is a`
- 要么使用继承并详细说明，要么不使用它
  - **继承会增加程序的复杂度**
- 遵循Liskov原则
  - 派生类必须通过基类的接口而被使用，且使用者无需了解两者之间的差异
- 派生类中的成员函数不要与基类中不可覆盖的成员函数重名，造成意料之外的“覆盖”
- 把共有的接口、数据及操作放到继承树尽可能高的位置
- **只有一个派生类的基类是值的怀疑的**
- **只有一个实例的类是值得怀疑的**
  - 单例模式（singleton）是一个特例
- 派生类覆盖了某个函数，但在其中没做任何操作，这种情况也是值得怀疑的
  - 谨记`不能抓的猫`的示例
  - **在源头解决问题，而不是在发现问题的地方修补**
- 避免让继承体系过深
- 尽量使用多态，避免大量的类型检查
- 让所的数据都是`private`（而非protected）
  - 这里的前提是**继承会破坏封装**。如果派生类需要访问基类的属性，应该通过`protected的函数访问器`

多重继承
- 慎用多重继承

总结：**当你想用基类控制接口时使用继承，反之，使用组合。**

其他段的汇总摘要
- `Demeter法则`：简而言之就是，调用方法时最多只有一个`.`。
- 优先使用`deep copy`而不是`shallow copy`，除非有合理的理由。
- **为未知的性能优化增加复杂度是不妥的**
