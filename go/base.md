# go

TODO: go中调用函数都是值传递？


## 程序结构

如果一个实体在函数中声明，它只在函数局部有效。如果在函数外声明，它将对于包里面的所有源文件可见。

实体第一个字母的大小写决定其可见性是否跨包。如果名称已大写字母开头，意味着它对于包外是可见的和可访问的。

go中每个文件已package开头，表明文件属于那个包。package之后是import声明。

### 变量

*var name type = expression*

type和expression可以省略一个。如果类型省略，它的类型将由表达式决定；如果表达式省略，其初始者对于于类型的初始值。


*name := expression*: 短变量声明

> `:=`表示声明；`=`表示赋值。

短变量声明不需要声明所有左边的变量；短变量声明最少声明一个新变量，否则，编译无法通过。

TODO: 感觉这里的限制挺多，之后研究一下

#### 指针

```go
x := 1
// 获取变量的指针
p := &x
// 通过指针获取值
*p = 2
```
- 指针的零值为nil
- 指针是可比较的。当两个指针指向同一个变量或都为nil是才相同

#### new函数

*p := new(T)*：创建一个未命名的T类型变量，初始化为T类型的零值，并返回其地址。
> new是一个预声明的函数，而不是一个关键字

### 类型声明

*type name underlying-type*: 定义一个新的命名类型。它和某个已有类型使用相同的底层类型。

命名类型的底层类型决定了它的结构和表达方式，以及它支持的内部操作集合，这些内部操作与直接使用底层类型的情况相同。

### 包和文件

包用于支持模块化、封装、编译隔离和重用。

每一个文件的开头用package声明定义包的名称。如果包级别的名字在包的一个文件中声明，就像所有的源代码都在同一个文件中一样。
TODO: 对于函数也是这样吗，这不会导致混乱吗？

go中每个包通过称为*导入路径*的唯一字符来标识。语言的规范中并没有定义那些字符串从哪里来以及它们的含义，这依赖于工具的解释。

当使用go工具时，一个导入路径表示一个目录，目录中包含构成包的一个或多个文件。除了导入路径之外，每个包还有一个包名，它以短名字的形式出现在包的声明中。按照约定，**包名匹配导入路径中的最后一段**。

go中任何文件可以可以包含任意数量的形如下列的函数`func init () {...}`。这个init函数无法被调用和被引用，另一方面，它也是普通的函数。在每个文件中，当程序启动时，init函数按照它们声明的顺序自动执行。

### 作用域

需要额外注意*短变量声明*的作用域

## 数据类型

### 整数
- int
  - 长度不固定，取决于平台和编辑器
- uint
  - 长度不固定，取决于平台和编辑器
- int8
- int16
- int24
- int32
- uint8
- uint16
- uint24
- uint32
- rune: int32的同义词，常用来指明一个unicode码点
- uintptr: 大小不明确，但足够存放指针类型

### 字符串
- bytes
- strings
- strconv
- unicode

### 常量

*const name type = value*

or

```go
const {
  name1 type1
  name2 type2
  ...
}
```

> iota

#### 无类型常量

go中的常量可以是任何基本类型，但许多常量并不从属于某一具体类型。从属类型待定的常量一共6中：无类型布尔、无类型整数、无类型文字符号、无类型浮点数、无类型复数、无类型字符串。

记住一个例子*math.Pi*，它并没有固定类型，而是可以放在任何浮点数和复数的地方。

## 复合数据结构

数组和结构体的长度时固定的；slice和map都是动态数据结构

### 数组

声明及初始化
```go
var a [3]int
var b [3]int = [3]int{1,2,3}
c := [...]int{1,2,3} // 使用...时表明长度由初始化数字元素的长度决定
```

数据的长度必须在程序编译时确定。数组的长度是数组类型的一部分。所以`[3]int`和`[4]int`被视为不同类型。

*如果数据中的元素类型时可比较的，那么这个数组就是可比较的*，可以直接使用`=`对两个数组进行比较。

当数组传递给函数时，函数接受的时数组的副本，而不是原始的参数。这样在函数内部对数组的修改，并不会影响原始数组。如果想要修改原始数组可以传入数组的指针。

### slice

slice通常使用*[]T*声明，其中T代表数据的类型。slice表示一个拥有相同类型元素的可变长度的序列。

数组和slice紧密相关。slice是一种轻量级的数据结构，可以用来访问数组的部分或者全部元素，而这个数组称为slice的底层数组。

slice有三个属性：指针、长度和容量。指针指向数组的第一个可以从slice中访问的元素，这个元素并不一定是数组的第一元素。长度是指slice中的元素个数，它不能超过slice的容量。容量的大小是从slice的起始元素到底层数组的最后一个元素间元素的个数。

因为slice包含指向数组的指针，所以将一个slice传递给函数时，可以在函数内部修改底层数组数据。

slice无法像数组一样，直接通过 *=* 比较两个slice中的元素是否相等。slice可以和`nil`进行比较。如果`slice==nil`表明其没有底层数组。

内置函数make可以创建一个具有指定元素类型、长度和容量的slice。其中容量参赛可以省略，在这种情况下，slice的长度和容量相同。
```go
make([]T, len)
make([]T, len, cap) // 等价于 make([]T, cap)[:len]
```

其实这里首先make创建了一个无名数组并返回了它的一个slice;这个数组仅可以通过这个slice来访问。

内置的*append*函数使用更复杂的正常策略。当使用append向一个slice添加一个元素是，我们无法确定是否发生了一次新的内存分配；我们也无法假设append之后slice是否还指向同一个底层数组，也无法证明它们是否指向相同的底层数组；我们也无法假设旧slice上对元素的操作是否会影响新的slice元素。所以，*通常将append的调用结果再次赋值给传入append的slice*。

### map

```go
ages := make(map[string]int)

ages := map[string]int{
  "a": 1,
  "b": 2
}
```

在map中还不存在的key对应的value是value类型的零值。通过下标的形式获取map总会有值，如果下标不在map中会返回类型的零值。

如何判断key是否在map中
```go
value, ok := map["key"]
if ok:{
  ...
}
```

### 结构体

```go
type Employee struct {
  ID int
  Name string
  ...  
}

var a Employee
a.ID = 1

// 也可以通过指针访问成员变量
var p *Employee = &a
a.ID = 2
```

成员变量的顺序对于结构体同一性很重要。如果改变结构体中成员变量的顺序，则会创建一个新结构体。

如果结构体中的成员变量名称是首字母大写的，那么这个变量是可导出的。一个结构体中可同时包含可导出和不可导出的成员变量。

命名结构体s中不能包含一个拥有相同结构体类型s的成员变量，也就是一个聚合类型不可以包含它自己。不过s中可以定义一个s的指针类型。

结构体字面量

```go
type Point struct { X, Y int}

p := Point{1,2}

p1 := Point{X:1, Y:2}
```

如果结构体中的成员变量都可以比较，那么这个结构体就是可比较的。两个结构体可以使用 *=* 或者 *！=*进行比较。

结构体嵌套和匿名成员

```go
type Point struct {
  X, Y int
}

type Circle struct {
  Point
  Radius int
}

type Wheel struct {
  Circle
  Spokes int
}

// 由于拥有结构体嵌套功能，所以可以直接访问到需要的变量，而不用指定一大串中间变量
var w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20

// 嵌套结构体的初始化
w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
  Circle: Circle{
    Point: Point{X:8, Y:8},
    Radius: 5,
  },
  Spokes: 20, //尾部的逗号是必须的
}
```
> 嵌套的结构体中“匿名成员”也是有名字的，就是对应类型的名字，只是这些名字在点号访问变量时是可选的。

> 由于“匿名成员”拥有隐式的名字，所以在一个结构体中无法定义两个相同类型的匿名成员。由于匿名成员的名字由其类型决定，所以它们的可导出性也有其类型决定。

### json

成员标签定义

## 函数

函数声明
```
func name(parameter-list) (result-list) {
  body
}
```

*函数实参按值传递*

go函数的返回值可以定义名称，对于定义名称了的函数可以省略return的操作数，这称为裸返回

### 错误处理

go中使用普通值而非异常来报告错误。go中的异常只是针对程序中的bug导致的预料之外的错误，而不是作为常规的错误处理方法出现在程序中。

其他语言使用异常来处理错误，会导致错误会以难以理解的栈跟踪信息报告给最终用户，而不是简单明了的错误信息。

*go中通常使用控制流机制（if和return）来处理错误。这种方式在错误处理逻辑方面要求的更加小心谨慎，这也是设计的要点。*

### 函数变量

函数可以作为对象传递，可以赋给变量或从其他函数中返回，它们的函数签名就是它们的类型。

函数可以和nil进行比较。不过函数之间是无法比较的。

### 匿名函数

注意闭包的使用，和python中有些许区别。

### 变长函数

go中的数据的打包和解包。

```go
func func1(vals ...int) int {}

values := []int{1, 2, 3, 4}
fmt.Println(sum(values...))
```

### 延迟函数调用

```go
// 使用示例
func func1() {
  defer func2()
}
```

defer会讲其之后的函数推迟到*函数结束*之后才执行。defer语句没有限制使用的次数；执行的是时候以调用defer语句的顺序倒序进行。

*较复杂的使用场景*，在函数的入口和出口处设置调试行为。

```go
func test() {
  defer func1()()
  
  time.sleep(10)
}

func func1(msg string) {
  start := time.Now()
  log.Printf("enter %s", msg)
  return func() { log.Printf("exist %s (%s)", msg, time.Since(start))}
}
```

### 恢复

如果内置的`recover`函数在延迟函数的内部调用，而且这个包含defer语句的函数发生宕机，`recover`会终止当前的宕机状态并且返回宕机的值。函数不会从之前宕机的地方继续运行而是正常返回。如果recover在其他任何情况下运行则它没有任何效果且返回nil。

从同一个包内发生的宕机进行恢复有助于简化处理复杂和未知的错误，但一般的原则是，你不应该尝试去恢复从另一个包内发生的宕机。公共的api应当直接报告错误。同样，当代码不是由你来维护时，也不应当恢复一个宕机。

## 方法

```go
type Point struct {X, Y float64}

// 通常使用类型的首字母作为接受者变量
func (p Point) Distance(q Point) float64 {
  return 100.1
}
```

每个类型都有自己的命名空间，所以不同类型可以拥有同名的方法。

命名类型(Point)和指向它们的指针(\*Point)是唯一可以出现在接受者声明处的类型。在真实的程序中，*习惯上*遵循如果一个命名类型的任何一个方法使用指针接受者，那么所有的方法都应该使用指针接受者，即使有些方法并不一定需要。

不论接受者是命名类型还是指向命名类型的指针，实际调用方法的方式相同。举例来说，如果接受者p是Point类型的变量，但方法要求一个`*Point`接受者，则调用时可以简写为`p.func1()`。

方法接受者可以为nil。

### 结构体相关

结构体能够直接调用其内嵌类型结构体的方法。

方法变量：将接受者和方法赋值给一个变量，之后调用时仅需要传入实参即可。

方法表达式：将方法赋值给一个变量，之后调用时将接受者作为第一个方法的第一个参数传入。

### 封装

go只有一种控制命名的可见性：通过标识符的首字母是否大小写，首字母大写的对外部可见，首字母小写的对外部不可见。

go中的封装通过*结构体*和*命名控制*来实现。

go中封装的单元是包而不是类型，在同一个包中的所有代码都是可见的。（区别于java）


## 接口

go中接口是一种数据类型。

一个接口类型定义了一套方法，如果一个具体类型要实现该接口，那么必须实现接口类型定义的全部方法。

接口之间可以通过组合构成新的接口。接口中的方法定义的顺序是没有意义的（区别于go中的结构体）。

空接口类型`interface {}`，可以将任何值赋值给空接口类型。

### 接口值

从概念上讲，接口值包含两部分：`一个具体类型（动态类型）`和`该类型的一个值（动态值）`。接口值的零值是他的动态类型和动态值都为nil。

接口值可以使用`==`和`!=`来进行比较。如果两个接口值都为nil或两者的动态类型完全一致且动态值相同，那么两个接口值相同。*不过需要警惕的是，如果两个接口值的动态类型相同，但动态值无法比较，会导致比较崩溃。所以使用接口值进行比较时，需要额外注意。*

*空的接口值和仅仅动态值为nil的几口值并不相同*









