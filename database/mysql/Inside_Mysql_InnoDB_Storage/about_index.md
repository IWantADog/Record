# 索引与算法

索引的类型
- b+树索引
- 全文索引
- hash索引

*InnoDB存储引擎支持的hash索引是自适应的*，InnoDB存储引擎会根据表的使用情况自动给表生成hash索引，不能人为干预是否在一张表上生存hash索引。

> 二叉查找树: 左子树的键值总是小于根的键值，右子树总是大于根的键值。

> 平衡二叉树：首先满足二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。

一个经常被忽略的问题：`B+树索引并不能找到一个给定键值的具体行。而只能找到所查找的数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。`b+树中的*叶子结点*和*非页纸结点*在内存及磁盘存储都是以页的形式进行存储。

cardinality值：表示索引中不重复记录数据的预估值，需要特别注意这个值是一个预估值，而非一个准确值。（等价于*选择性*）。当某一列的选择度越高，索引的建立才有意义。

## 索引的使用

### b+树
联合索引

*联合索引b+树内部存储与单个索引没有多大的区别*。唯一的区别是联合索引是按照定义索引时列的顺序进行比较排序的。例如(a,b,c)索引，（1,1,1）< (1,1,2) < (1,2,1) < (2,1,1)。

对于一张表如果创建了(col1, col2, col3)索引，则查询时使用(col1)、（col1, col2)、(col1, col2, col3)都会使用索引。


索引提示：显示设置查询使用的索引。*当数据库优化器使用了错误的索引*或*索引太多，选择合适的索引使用过长的时间*时可以使用。不过这需要仔细的比较使用不同索引之间的性能差异。

[MRR(Multi-Range Read)优化](https://dev.mysql.com/doc/refman/8.0/en/mrr-optimization.html)

MRR优化的目的是为了减少磁盘的随机访问，并且将随机访问转换为比较顺序的数据访问，这对于IO-bound类型的sql查询语句能够带来极大的性能提升。
- MRR使数据的访问变的较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。
- 减少缓冲池中页被替换的次数
- 批量对键值的查询操作

启用mrr。相关的参数有两个*optimizer_switch*中的*mrr*和*mrr_cost_based*。当*mrr=on*时表明mrr启动。当*mrr_cost_based=off*时表明总是启动MRR优化。

ICP(index condition pushdown)优化

未启用ICP时，在进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录。启用ICP后，mysql会在取出索引的同时，判断时候可以通过where条件进行过滤，也就是将where的部分过滤放在了存储引擎层。在某些查询下，可以大大减少上层sql层对于记录的获取，从而提升数据库的性能。

### hash算法

> 链接法: 当出现hash碰撞时，将相同hash的数据放在一个链表中

自适应hash索引

### 全文索引

全文索引一般使用*倒排索引*来实现。倒排索引同B+树索引一样，也是一种索引结构。他在辅助表(auxiliary table)中存储单词和单词自身在一个或多个文档中所在位置之间的映射。通常使用关联数组实现，其拥有两种表现形式:
- inverted file index，其表现为*{单词，单词所在的文档ID}*
- full inverted index，其表现为*{单词，(单词所在文档的ID，在具体文档中位置)}*

innodb的全文索引采用了*full inverted index*的方式实现。其全文索引表中，有两个列，一个时word字段，另一个时ilist字段，并且在word字段上设有索引。

auxiliary table是持久的表，存放在磁盘上，当同时InnoDB的全文索引中有另一个重要的概念*FTS Index Cache（全文检索索引缓存）*，用来提高全文索引的性能。

FTS Index Cache是一个红黑树结构，其根据(word, ilist)进行排序。当插入新数据时，会先更新*FTS index cache*，但时Auxiliary table并不会立即更新。InnoDB存储引擎会对Auxiliay table进行批量更新。当对全文索引进行查询时，Auxiliary Table首先会将FTS Index Cache中对应的word字段合并到Auxiliary table中，然后在进行查询。
