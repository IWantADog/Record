# 深入浅出https

## http遇到的问题
- 数据没有加密
- 无法验证身份
- 数据易被篡改

## 密码学

### 密码学的四个目标
1. 机密性
  - 通过加密算法保证
2. 完整性
  - 通过MAC（消息验证码）算法保证
3. 身份验证
  - 通过数字签名技术保证
4. 不可抵赖
  - 通过数字签名技术保证

### 密码学中的基本

#### 随机数

随机数中的特性
1. 效率
2. 随机性
  - 比如随机数生成器从0到9几个数字中挑选出4个数字，在生成的随机数中，0到9出现的次数是平均的。
3. 不可预测性
4. 不可重现性

#### hash算法

密码学中的hash算法的主要特性
- 相同的消息总能的到相同的摘要值，特定的hash算法，不管消息的长度是多少，最终的摘要值的长度是相同的
- 不管多长的消息，hash运算非常快速
- 通过摘要值很难逆向计算出原始消息，hash算法具备单向性，摘要值是不可逆的
- 原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会发生变化
- 对于两个不同的消息，他们的摘要值很难相同

主要用途
1. 文件比较。常用的就是通过md5进行文件校验
2. 身份校验

安全的密码学hash算法
- 不同的消息对应的摘要值应该不同
  - TODO: 如何理解 *collision Resistance* & *pre-image Resistance* & *second pre-image Resistance*
    - https://crypto.stackexchange.com/questions/1173/what-are-preimage-resistance-and-collision-resistance-and-how-can-the-lack-ther
- 单向性：给出一个摘要值很难找出它的原始信息

hash算法分类
- md5
- SHA
- SHA-2
- SHA-3

### 对称加密算法

加密解密使用的是同一套密钥和算法

两种类型
- 块密码算法
- 流密码算法

### 消息验证码（message authentication code）

加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改。

加密算法虽然能够保证攻击者无法破解原文。但是无法避免攻击者修改部分数据。这样即使数据被破解，但是消息却已经被修改了。

AE加密模式
1. Encrypt-and-MAC(E&M): 分别对消息进行加密运算和MAC运行，之后将消息进行组合
2. MAC-then-Encrypt(MtE): 先进行MAC运行，之后将消息和MAC组合并一起加密
3. Encrypt-then-MAC(EtM): 先加密，再对密文进行MAC运算得到MAC值，最后组合数据。

AEAD加密模式

AEAD是AE模式的变体，AE模式需要使用者单独处理加密运算和MAC运算。AEAD则在底层组合了机密算法和MAC算法。
- CCM
- GCM
- ChaCha20-poly1305


### 非对称加密算法（公开密钥算法）

对称加密和非对称加密的区别
1. 功能不同。
  对称加密主要用于加密和解密。而非对称加密不仅可以用于加密解密，还可用于密钥协商、数字签名。
2. 密钥是一对。
  公钥加密，私钥解密。公钥可以给任何人，公钥仅能加密数据但无法解密数据，但私钥只能由密钥对的生成方保存。
3. 运行速度慢

> 著名的非对称加密方式是RSA算法。

密钥协商算法
- RSA密钥协商算法
  1. 客户端初始化连接服务器，服务器发送RSA密钥对的公钥给客户端
  2. 客户端生成一个随机值，这个值必须是随机的，不能被攻击者猜出，这个值就是会话密钥
  3. 客户端使用服务器RSA密钥对的公钥加密会话密钥，并发送给服务端，由于攻击者没有服务器的私钥，所以无法解密会话密钥
  4. 服务器用的他密钥解密出会话密钥
  5. 至此双方完成连接，接下来服务端和客户端可以使用对称加密算法和会话密钥加密解密数据。
- DH密钥协商算法

> 密钥协商算法，解决的是密钥的存储和安全传输问题。

### 数字签名

数字签名生成的流程
1. 发送者对消息计算摘要值
2. 发送者用私钥对摘要值进行签名得到签名值
3. 发送者将原始消息和签名值一同发送给接受者

数据签名验证流程
1. 接受者收到消息后，拆分出消息和消息签名值A
2. 接受者使用公钥对消息进行运算得到摘要值B
3. 接受者对摘要值B和签名值A进行比较，如果相同表示签名验证成功，否则就是验证失败

> 数字签名的标准算法DSS（digital signature standard）

> RSA加密算法是公钥加密，私钥解密；RSA签名算法是私钥签名，公钥验证签名。

### 算法安全性和性能

尽量先选择安全性高的算法，再在此基础上选择性能高的算法。

## 宏观理解TLS

*openssl*

openssl是一个底层密码库，封装了所有的密码学算法、证书管理、TLS/SSL协议实现。

openssl包含两个类型的库。
- crypto库函数：具体的密码学算法使用库，比如MD5、RSA、DES算法的实现，开发者可以直接使用这些库，可以理解为低层次库。
- EVP接口：高层次库，基于crypto库函数做了进一步抽象。

*https和tls/ssl的关系*

构建在TCP之上的应用层协议（比如HTTP）都能结合TLS/SSL协议，TLS/SSL协议和应用层协议无关，它只是加密应用层协议（HTTP）并传递给下层的TCP。

HTTP和TLS/SSL协议组合在一起就是HTTPS，HTTPS等于HTTP + TLS/SSL。就是说https拥有HTTP所有的特性，并且HTTP消息由TLS/SSL协议进行安全保护。

http server和客户端（浏览器）一般不会实现自己实现TLS/SSL协议，而是直接调用底层系统上的OpenSSL库完成TLS/SSL协议的工作。

### TLS/SSL协议背后的算法

TLS/SSL无法解决中间人攻击，必须结合PKI技术进行解决。

在TLS/SSL协议中，*协商*的另一个关键名词就是密码套件，协商的结果就是双方都认可的密码套件，密码套件决定了本次连接采用哪一个加密算法、密钥协商算法、HMAC算法。

密钥协商算法
- RSA
- DH算法
  - 静态DH
  - 动态DH

*向前兼容性问题*

如果使用RSA或静态DH算法，客户端在不同连接之间使用相同的密钥。如果攻击者记录了历史客户端和服务器之间的数据，当密钥泄漏之后，历史的全部数据就会被被机密。

而如果使用动态DH，客户端每次连接的时候，DH密钥对都是重新生成的，即使在某次连接中泄漏了，也仅仅会导致本次连接中加密数据被破解，安全风险相对小些。

*中间人攻击*

所谓的中间人攻击就是服务器传递给客户端公钥可能被攻击者替换。

客户端访问一个网址，接收到一个服务器公钥，但是无法确定公钥是不是真正属于对应的网址。公钥只是一串数字，需要一种手段去认证公钥的真正主人。

公开密钥算法中，所有的网络通信都会存在中间人攻击。HTTPS协议必须引入PKI技术解决身份验证的问题，其中的核心就是证书。

*PKI*

PKI是一个很宽泛的概念。PKI由多个不同的组织构成，组织之间需要一定的信任基础。
- 服务器实体
  - 向CA机构申请证书。
- 客户端。
  - 客户端内部会集成CA机构的根证书。
- CA机构
  - CA机构向服务器实体签发证书。
  - 证书一般包括
    - 服务器实体信息：服务器主机名、服务器公钥。
    - CA机构的信息：比如CA机构数字签名算法标识符、签名值。
  - 获取证书的途径
    1. 向收费的CA机构申请证书
    2. 向免费的CA机构申请证书
    3. 生成自签名的证书


申请证书的流程，大体如下
1. 服务器实体希望发布一个HTTPS网站。
2. 服务器实体生成公开密钥算法的一对密钥。
3. 服务器实体生成一个CSR（Cerificate Signing Request），CSR是证书签名请求的文件，其中包含的重要信息是网站的域名、RSA密钥对的公钥、营业执照，然后将CSR文件发送给CA机构申请证书。
4. CA机构收到CSR文件后，核实申请者的身份。
5. 一旦审核成功，CA机构就使用自己密钥对中的私钥签名CSR文件的内容得到签名值，然后将签名值附在CSR文件后面得到证书文件，证书文件中除了包含申请者的信息，还会包含CA机构的信息，比如包括CA机构采用的签名算法、CA机构的名称。
6. 最终CA机构将签名发送给服务器实体。


客户端校验证书的流程
1. 浏览器向服务端发送请求。
2. 服务器接受到请求之后，将证书文件和RSA密钥对的公钥发送给浏览器。
3. 浏览器接受到证书文件，从中判断出是某个CA机构签发的证书，并进行验证。
4. 一旦验证通过，则代表该证书确实和合法CA机构签发的。
5. 浏览器接着验证证书申请者的身份，从证书中取出RSA公钥和主机名。如果证书中的公钥和服务器返回的公钥相同，且证书中的主机名也和请求的相同，则校验成功。

### HTTPS总结

HTTPS中的TLS/SSL分为两层: 握手层、加密层。

握手层在加密层的上层，握手层提供加密层需要的密钥块，对于一个HTTPS请求来说，HTTPS消息在没有完成握手之前，是不会传递给加密层的，一旦握手层处理完毕，应用层所有的HTTP消息交由加密层进行加密。

#### 握手

握手包含4个概念
1. 认证
2. 密码套件协商
3. 密钥协商
4. 握手信息完整性校验

*认证*

通过证书确定服务器的身份，避免中间人攻击。

*密码套件协商*

客户端和服务端需要协商出双方都认可的密码套件，密码套件决定了本次连接客户端和服务端之间采用的加密算法、HMAC算法、密钥协商算法等各类算法。

*密钥协商*

使用协商的密钥套件，确定密钥。

*握手消息完整性校验*

握手消息完整性校验十分重要。握手过程中的消息全都是明文传输的，任何攻击者都能够截获，握手消息存在被篡改的可能性。

> 经过证书之后，应该不存在中间人攻击。这里握手信息被篡改，没有理解具体的场景。TODO:

简单描述TLS/SSL如何保证消息的加密性和完整性
1. 客户端将发送和接受到的所有握手消息组合在一起，然后计算出摘要数据，握手层使用密钥块对摘要数据进行加密和完整性保护，然后发送给服务端。
2. 服务端收到验证消息后，使用加密块解密出摘要数据。
3. 服务端自行计算发送和接受的所有握手信息，再计算出消息的摘要数据，如果摘要数据和解密出的摘要数据相同，代表客户端发送的数据没有被篡改。

同理，服务端也要计算验证消息，然后发送给客户端进行校验。需要注意的是，客户端和服务端计算的摘要数据是不一样的，因为双方发出和接收的消息不一样，顺序也不一样。

#### 加密

- 流密码加密模式
- 分组加密模式
- AEAD模式

## 证书

PKI（Public Key Infrastructure）公钥基础设施

```plant
@startuml
agent 服务器实体
agent CA机构
agent 证书仓库
agent web服务器
agent 浏览器
agent OCSP服务


服务器实体 -left-> CA机构 : 发送CSR
CA机构 -right-> 服务器实体: 发送证书
CA机构 -left-> 证书仓库: 更新
CA机构 --> OCSP服务: 部署
证书仓库 --> OCSP服务: 请求
服务器实体 -down-> web服务器: 部署证书
web服务器 -down-> 浏览器: 校验证书
浏览器 -up-> web服务器: 请求证书
OCSP服务 --> 浏览器: 校验证书吊销状态
@enduml
```

### 证书的基本构成
1. version: 证书的版本号。目前有3个版本（v1, v2, v3）。证书校验方会根据版本进行校验。
2. serialNumber: 证书的唯一序列号
3. signature: 签名算法。同时包含摘要算法和签名算法
4. issuer: CA机构的名字
5. validity: 证书的有效区间
6. subject: 服务器实体名称
7. subjectPublicKeyInfo: 服务器公钥和对应的公开加密算法

> 还有其他字段，不重要就省略了。

### CSR（Certificate Signing Request）

服务器实体在申请证书之前，需要准备一个CSR文件。CSR文件包含两部分。
1. 域名、公钥
2. 服务器实体的证明材料。

### 证书的分类

*按照验证模式区分*
- DV证书
- OV证书
- EV证书

*按照域名进行分类*
- 单域名证书: 一个域名一个证书
- 泛域名证书: 将多个同级的域名合并到一张证书中，泛域名证书的优点在于增加新主机时不用更新证书
- SAN证书: 将多个注册域进行合并
- SAN泛域名证书: 结合了SAN证书和泛域名证书的特点

### 证书链

证书链中，证书可以分为服务器实体证书、中间证书、根证书。上一级证书签发下一级证书。根证书的签发者和使用者相同。下一级证书的签发者是上一级签证书的使用者。

信任锚的概念：浏览器必须信任根证书。


证书链存在的根本目的是什么？

理解这个问题需要先搞清楚CA机构的运作模式。CA机构的运作模式有两种，分别是委派认证和交叉认证。

*委派认证*

一般情况下，根CA机构意义重大，想直接嵌入各种操作系统或设备的根证书非常不容易，根CA机构不会直接签发服务器实体证书。
- 如果为每个服务器实体申请证书，根CA机构的工作量会非常大。而且还不好处理本土化的问题。
- 二级CA机构证书升级更方便。比如当需要升级二级CA证书使用的签名算法时，不用通知证书校验方，因为证书校验机构只包含根CA机构的根证书，而根证书的升级是非常麻烦的，这样会导致证书校验方的版本升级。

所以一般的方式是委派一个二级机构来签发证书。


*交叉认证*

一个新的CA机构如果想要投入服务，不可能立刻嵌入到证书校验方可信证书列表中，解决方案是让另一个根CA机构对其进行交叉认证。
