# PEP 3333

## The Application/Framework Side

application对象 __必须是可调用的__ 并且 __接受两个参数__ 。application能够被调用多次。

`application`对象必须包含两个参数，一般便于说明将变量命名为`environ` & `start_response`。

- `environ`是一个`dict`，存储`CGI-style`变量以及WSGI需要的其他变量。而且必须为`build-in dict`，不能是其他dict的子类。

- `start_response`必须为一个`callable object`并且能够接受三个参数，其中两个为必选。`application`调用时直接使用位置参数。`start_response(status, response_headers)`。[The start_response() Callable](#start_response)

__application对象被调用后必须返回一个可迭代多个`string`的对象。可以是个列表，也可以是个生成器。__


当applicaiton对象被调用时，必须返回一个可迭代对象返回空或者多个`bytestring`。

// todo 理清楚整个请求的整个回调流程，搞清楚可以访问和修改那些数据。

如果applicaiton返回的可迭代对象实现了`close`方法，则server必须在请求结束时调用`close`，不论请求是否抛出异常。// todo 这是为了干什么？

`application`必须在可迭代对象产生第一个输出之前先调用`start_response`。这样`server`就能在发送`body content`之前发送`header`。// todo server是向client发送数据吗？


## The Server/Gateway Side 

server/gateway对于每个请求都会调用`applicaiton callable`。

调用`application callable`并向其中传入`environ` & `start_response`。

server必须以`非缓存的方式`传递`string`给client。(这其实意味着applicaiton需要自己实现缓存 TODO: 是否是这样？)


## About Middleware

中间件对于`application`相当与`server`，对于`server`相当与`applicaiton`。这也意味着通常情况下，`middleware`需要同时符合`application`和`server`共同的限制和要求。

> 考虑`server`对`milddleware`的调用时，`middleware`需要符合application的接口要求。

> 考虑`middleware`对`application`的调用时，`middleware`需要满足`application`的接口要求。

middleware的功能如下：
- 当请求到来后可以修改`environ`，将不同的请求导向不同的applicaiton。
- 在同一个过程中，允许多个`application/frameworks`一个接一个的执行。
- 负载均衡和远程处理（TODO: 远程处理具体指什么）
- 执行内容后处理（TODO: 什么意思）


## environ 变量

## start_response

__`start_response`被用来开始http响应，并且必须返回一个`write(body_data) callable`。__

输入参数:
- status是类似 `999 Message here` 的字符串。
- response_headers是一个由`(header_name, header_value)`构成的list。
- exc_info是可选的，用于捕获`error`并抛给浏览器。

返回参数:
- `write(body_data)`必须是一个`callable`，并且`接受一个位置参数`（一个`string`需要能够被写入http response body）。（write() callable只是为了兼容旧的framework和applicaiton）

start_response不能直接传输`response header`，必须先暂时存储`response header`直到`application`返回第一个非空的字符串；或是直到`application`第一次调用`write()`。换句话说就是，`response header`不能被发送，需要等到`response body date`可以访问；或是`application`返回的可迭代对象被完全消耗。

这样的做的目的是，保证对于`缓存`和`异步`的应用`在最后的可能时刻对输出进行修改`。

TODO: 这是否意味着，在application中需要将`start_response`放在代码的最后执行？？

`exc_info`如果需要的话，必须为`sys.exc_info()`的返回值。如果`exc_info`被指定，`response_header`没有被指定，这时需要使用新的`http_header`替换可能已经缓存的header；如果`response_header`已经指定，则需要由`start_response``raise Exception`。

如果当前的application的`start_response`已经被调用，**之后的重复调用必须携带`exc_info`**，不然就是严重的错误。

## Handling the Content-Length Header

如果`application`提供了`Content-Length`字段，server发送的数据大小不能超过该数值。如果发送的数据量超过了指定的数值，server需要停止继续发送数据，如果`applicaiton`继续发送数据，`server`需要能`抛出异常`；如果`applicaiton`没有提供足够的数据，`server`需要终止连接并记录日志或做其他处理。

https://www.python.org/dev/peps/pep-3333/#id27

```py
# practice code
from werkzeug.serving import run_simple
from werkzeug import Response

def create_app():
    return Response("hello world!")

class MyMiddleware:
    def __init__(self, application) -> None:
        self.application = application

    def __call__(self, environ, start_response):
        print("in my middleware")
        self.application.set_data("this is new value")
        return self.application(environ, start_response)

if __name__ == '__main__':
    app = MyMiddleware(create_app())
    run_simple("127.0.0.1", 5000, app, use_debugger=True, use_reloader=True)
```