# 事务

ACID
- A: 原子性
- C: 一致性
- I: 隔离性
- D: 持久性

## 事务的实现

- redo log: 保证数据库的原子性、持久性
- undo log: 保证数据库的一致性
> 数据库的隔离性由锁来实现

### redo

当数据库意外崩溃，需要恢复数据时，会使用redo。

redo log分为两部分: redo log buffer重做日志缓冲;redo log file重做日志文件。

为保证每次日志都写入日志文件，在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作。由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。

参数*innodb_flush_log_at_trx_commit*用来控制重做日志刷新到磁盘的策略，所有取值有0、1、2，默认值为1。
- 0: 表示事务提交时不进行写入重做日志操作，则个操作仅在master thread中每1秒执行一次
- 1: 表示事务提交时必须执行一次fsync操作
- 2: 表示事务提交时讲重做日志写入重做日志文件，但仅写入文件系统的缓冲中，不进行fsync操作。在这个设置下，当mysql数据库发生宕机而操作系统不发生当即时，并不会导致事务的丢失;而当操作系统宕机时，重启数据库后会丢失未从文件系统缓存刷新到重做日志文件的那部分数据。

从效率的角度看 0 > 2 > 1。但策略0和2都有丢失数据的风险。

二进制文件(binlog)

二进制文件最要用来进行`point in time`的恢复以及主从环境的建立。*谨记两者的区别*。
- *产生方式不同*: 重做日志是在InnoDB存储引擎层产生，二进制日志是在mysql数据库的上层产生的。并且二进制日志不仅仅针对于InnoDB存储引擎，mysql数据库中的任何存储引擎对于数据库的更改都会产生二进制日志
- *内容不同*: 二进制日志是一种逻辑日志，其记录的是sql语句。而重做日志是物理格式日志，其记录的是对每个页的修改。
- *写入磁盘的时间点不同*: 二进制日志只在事务提交完成后进行一次写入；而InnoDB存储引擎的重做日志在事务进行中不断的被写入。

### undo

*当事务中sql执行失败后，需要回滚时，才需要使用undo。使用undo的优点是提高了性能避免从redo log读取数据带来的额外的io读取。*

undo log的存储位置

undo log -> undo log segments -> rollback segments -> undo tablespaces -> global temporary tablespace
> *注意redo和undo的存储位置不同*

undo对数据库进行恢复的时候，进行的是逻辑上的恢复，例如用户在一个事务需要会滚数据库，对于事务中已经执行的每个insert，InnoDB存储引擎会执行一个delete；对于每个delete，会执行一个insert；对于每个update，会执行一个相反的update，将修改之前的数据放回去。

除了回滚操作，undo的另一个用途是，在InnoDB存储引擎中MVCC的实现是通过undo进行的。当用户读取一行记录时，如果该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。

undo log并不会在事务提交之后被删除，因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log页由purge线程来判断。

### purge

delete和update操作可能并不直接删除原有的数据。仅是将undo log中的对应数据的delete flag设置为1，记录并没有被立即删除。真正的删除会在purge中进行。这样做的原因是该行记录可能还被其他的事务使用，还不能立即删除。

## 事务控制语句

mysql命令行的默认配置下，事务都是自动提交的，即执行sql语句之后就会立即执行commit操作。
