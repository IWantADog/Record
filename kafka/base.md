# base

## 基本概念
- Producer: 生产者，发送消息的一方。
- Consumer: 消费者，消费消息的一方。
- Broker: 服务代理结点。对于kafka而言，Broker可以简单地看作一个独立的kafka服务节点或kafka服务实例。

  大多数情况下可以将Broker看作一个Kafka服务器，前提是这个服务器上只有一个kafka实例。一个或多个Broker组成一个Kafka集群。
- Topic: 

  kafka中消息以主题为单位进行归类，生产者负责将消息发送到特定的主题。消费者负责订阅主题并进行消费。
- Partition:

  topic是一个逻辑上的概念。一个主题还可以细分为多个分区，一个分区只属于一个topic。

  **kafka上的分区可以分布在不同的服务器(broker)上，也就是说，一个主题可以横跨多个broker，以此提供比单个broker更强大的性能。**
- offset:

  在存储层面上，一个分区可以被视为一个可追加的日志文件，消息在被追加到分区日子文件的时候都会分配一个特定的偏移量(offset)。

  offset是消息在分区中的唯一标识，kafka通过它来保证消息在分区中的顺序性。不过offset并不跨分区，也就是说，kafka保证offset在分区有序而不是在整个主题有序。

### kafka分区的多副本机制
- 同一个分区的不同副本保存的是相同的消息
- 副本之间是一主多从的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。
- 副本位于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。
- 一些相关的概念
  - AR(assigned replicas): 所有的副本的统称，包括leader副本
  - ISP(In-Sync Replicas): 所有与leader副本保存一定程度同步的副本（包括leader副本在内）
  - OSP(Out-Of-Sync Replicas): 与leader副本同步滞后过多的副本（不包括leader副本）

  由此可见 AR=ISP + OSP。不过在正常情况下，所有副本都应该与leader副本保存一定程度的同步，即AP=ISP，OSP集合为空

  - HW(High Watermark): 描述一个分区特定的offset，消费者只能拉到这个offset之前的消息。
    - HW保证分区多副本情况下数据的一致性。多个follower副本与leader副本之间的数据同步可能并不一致，此时该分区的HW就是同步数据最少的follower的最大offset+1。

      例如一个分区有1个leader，2个follower。某一时刻，leader中有4份数据，follower_1完全同步了4分数据，follower仅仅同步了3分数据。 则此时的这个分区的HW为4。
  - LEO(Log End Offset): 表示当前日志文件中下一条待写入消息的offset。

## zookeeper

zookeeper只要用于保存kafka集群的元数据。包含：集群中有哪些主题，这些主题位于那些分区，每个分区的leader副本被分配在那个节点，follower副本被分配在那些节点上。那些副本在AR、ISR中，集群中有哪些节点。

## 消费者基本概念

消费者与消费组
- 消费组是一个逻辑上的概念。
- 消费者并不是一个逻辑上的概念，而是一个具体的线程或进程。同一个消费组的消费者既可以部署在一台机器上，也可以部署在不同的机器上。
- 每个消费者必须属于一个消费组。当消息被发布到主题后，**会被投递给每个订阅它的消费组中的一个消费者**。

  也就是说，**每个消费组都会获取订阅的主题的全部数据**。**并且一个消费组中，不同的消费者获取数据不会重复。**
- 保证一条记录不会被一个组中的多个消费者获取的实现是：一个主题分区只能被一个消费组中的一个消费组消费。

使用注意

消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性。可以增加（或减少）消费者的数量来提高（或降低）整体的消费能力。

**不过对于分区固定的情况，如果一味的增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区数的情况，就会出现有消费者分配不到任何分区的情况。**

### 客户端使用
- 一个消费者开始消费之前，需要确定该消费组消费一个主题中的那些分区。
- 配置信息
  - enable.auto.commit: 是否启动自动提交。自动提交的时间间隔由`auto.commit.interval.ms`决定，默认时间为5s。
  - auto.offset.reset:
    使用场景:

    - 当消费者第一次消费指定主题时，无法找到消费位移，此时就会根据`auto.offset.reset`决定从何处开始消费。
    - 当消费者消费时，能够找到消费位移，`auto.offset.reset`则不会生效
    - 当消费者消费时，如果给定了在分区中无法找到的消费位移，这种情况被称为消费越界。发生消费越界时，也会根据`auto.offset.reset`来决定新的消费位置。
- seek: 通过代码设置分区的offset
- 再均衡

  再均衡是指：分区的所属权从一个消费者转移到另一个消费者的行为。

  不过当发生再均衡时，消费组内的消费者是无法读取消息的。也就是说，**在再均衡发生的这一段时间内，消费组会变的不可用**。并且**当一个分区被重新分配给另一个消费者时，消费者当前的状态也会丢失**。比如，消费者消费完某个分区中的一部分数据还没来得及提交消费位移就发生了再均衡操作，之后这个分区又被分配给了消费组内的另一个消费者，原来被消费完的那部分消息又被重新消费了一遍，也就发生了重复消费。

  所以，**应尽量避免不必要的再均衡发生**。

常规的消费组模型
- 一个分区对应一个threading。每个threading使用自己的Consumer。
  优点:
    - 简单
  缺点:
    - 存在threading数量不能大于分区数量的限制
    - 一个threading一个tcp链接，当threading数量过多时，tcp链接的数量也会过多。
- 一个分区对应一个threading pool。拉去数据后，启动一个子threading进行处理
  优点:
    - 突破了分区数量对于threading数量的限制，并且没有增加tcp的数量
  缺点:
    - 复杂性增加
    - 数据处理的顺序性无法保证
    - offset的顺序提交无法保证
- threading pool滑动窗口版

  维持一个滑动窗口，start_offset/end_offset分别指向窗口中的第一个和最后一个数据。

  当start_offset指向的数据被消费完成，则提交位移，与此同时，窗口向前滑动一格，删除start_offset对应的数据，并且拉取新的消息进入窗口。

## 分区与主题

优先副本的选举

- 副本分为leader副本和follow副本。leader副本负责对外提供读写服务，follow副本负责在内部进行消息的同步。
- 针对一个分区，同一个broker节点中不可能出现它的多个副本，即kafka集群中的一个broker中最多只能有它的一个副本。
- 优先副本的概念: AR列表中的第一个副本(书上解释的并不清楚)。理想情况下，每个leader副本都应该是优先副本。
