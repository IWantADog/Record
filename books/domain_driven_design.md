# Domain Driven Design

## 摘录

极限编程假定人们可以通过重构来改进设计，而且可以经常、快速地完成重构。

统一概念，所有的人使用同一种术语，避免概念的混淆和歧义。

将模型作为语言的中心。确保团队在所有的交流活动和代码中坚持使用这种语言。


### 分离领域

给复杂的应用程序划分层次。在每一层分别进行设计，使其具有内聚性并且只依赖于它的下层。采用标准的架构模式，只与上层进行松散链接。将所有与领域模型相关的代码放在一个层中，并把它与用户界面层，应用层以及基础设施层的代码分开。领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。

将领域层与基础设施层以及用户界面层分离，可以使每层的设计更加清晰。彼此独立的层更容易维护。

保持层与层之间的独立，保证层与层之间的单向依赖

项目团队常犯的错误是采用了一种复杂的设计方法，却无法保证项目从头到尾始终使用它。另一种常见的也是代价高昂的错误则是为项目构建了一种复杂的基础设施，并使用顶级的工具，而这样的项目根本不需要他们。

### 软件中所表示的模型

entity、value object、service

entity：一个实体，拥有唯一标识以区分不同。包含多个value object

service：强调的是与其它对象的关系，它定义了能够为用户做什么。service以一个动词命名，而不是一个名词命名。
  - 一些领域概念不适合被建模为对象。如果勉强地把这些重要的领域功能归为entity或value object的职责，那么不是歪曲了基于模型的对象定义，就是人为地增加了一些无意义的对象。


模式：

module: 注意module中的高内聚性、低耦合性。通过高内聚低耦合进而降低理解模块理解的难度，进而控制复杂度。

同时需要控制分层的弊端，如果层拆分的过于零散，反而会提升对于代码的理解成本。最好是将所有单一概念的代码，放在同一个module中

### 领域对象的生命周期

对于复杂的对象，创建对象本身可能就是一个复杂的过程。让对象自己负责进行创建，会降低对象的易用性。更合理的方式是单独实现工厂函数，承担这部分职责。

122

