# Domain Driven Design

## 摘录

极限编程假定人们可以通过重构来改进设计，而且可以经常、快速地完成重构。

统一概念，所有的人使用同一种术语，避免概念的混淆和歧义。

将模型作为语言的中心。确保团队在所有的交流活动和代码中坚持使用这种语言。


### 分离领域

给复杂的应用程序划分层次。在每一层分别进行设计，使其具有内聚性并且只依赖于它的下层。采用标准的架构模式，只与上层进行松散链接。将所有与领域模型相关的代码放在一个层中，并把它与用户界面层，应用层以及基础设施层的代码分开。领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。

将领域层与基础设施层以及用户界面层分离，可以使每层的设计更加清晰。彼此独立的层更容易维护。

保持层与层之间的独立，保证层与层之间的单向依赖

项目团队常犯的错误是采用了一种复杂的设计方法，却无法保证项目从头到尾始终使用它。另一种常见的也是代价高昂的错误则是为项目构建了一种复杂的基础设施，并使用顶级的工具，而这样的项目根本不需要他们。

### 软件中所表示的模型

entity、value object、service

entity：一个实体，拥有唯一标识以区分不同。包含多个value object

service：强调的是与其它对象的关系，它定义了能够为用户做什么。service以一个动词命名，而不是一个名词命名。
  - 一些领域概念不适合被建模为对象。如果勉强地把这些重要的领域功能归为entity或value object的职责，那么不是歪曲了基于模型的对象定义，就是人为地增加了一些无意义的对象。


module: 注意module中的高内聚性、低耦合性。通过高内聚低耦合进而降低理解模块理解的难度，进而控制复杂度。

同时需要控制分层的弊端，如果层拆分的过于零散，反而会提升对于代码的理解成本。最好是将所有单一概念的代码，放在同一个module中

### 领域对象的生命周期

#### Factory

对于复杂的对象，创建对象本身可能就是一个复杂的过程。让对象自己负责进行创建，会降低对象的易用性。更合理的方式是单独实现工厂函数，承担这部分职责。

对象的创建本身可以是一个主要操作，但被创建的对象并不适合承担复杂的装配操作。将这些职责混合在一起可能导致出现难以理解的拙劣设计。让客户端直接负责创建对象又会使客户的设计陷入混乱，并且破坏被装配对象或AGGREGATE的封装，而且导致客户与被创建对象的实现之间产生过于紧密的耦合。

**Factory的职责是封装对象存储和重建时的生命周期转换。本质是简化复杂对象的实例化过程。**


#### Repository

为每种需要全局访问的对象类型封装一个对象，这个对象就相当于该对类型的所有对象在内存中的一个集合的替身。通过一个众所周知的接口来提供访问。
- 提供增加和删除对象的方法，用这些方法来封装在数据实际存储中的插入或删除数据的操作。
- 提供根据具体标准来挑选对象的方法，并返回属性值满足查询标准的对象或对象集合（所返回的对象是完全实例化的），从而将实际的存储和查询技术封装起来。

**Repository的职责是提供对象和存储之间的相互转换。**
