# High Performance MySQl

- [x] 3. 服务器性能剖析
- [x] 4. schema于数据类型优化
- [x] 5. 索引
- [x] 6. 查询数据优化
7. mysql高级特性
8. 优化服务器配置
14. 应用程缓存


## 逻辑架构

```puml

```

## 不同存储引擎的特性
- InnoDB
- MyISAM

95%的情况下都选择InnoDB

## mysql基准测试

sysbench

## 服务性能剖析

- 分析慢查询日志
  - `pt-query-digest`工具
- 剖析单条查询
  - 使用`show profile`
  - 使用`show status`
  - `Performance Schema`
    - 书上不是很推荐，应为写书的时候，该特性还不完善，不知道现在怎么样了
- 确认时单条查询问题还是服务器问题
  - `show global status`每秒获取服务器状态
  - `show processlist`获取线程状态

## 选择优化的数据结构


### 整数类型
- tinyint/smallint/mediumint/int/bigint，分别使用8, 16, 24, 32, 64位存储空间，可以存储的值的范围从`-2 ** (n-1)`到`2 ** (n-1) - 1`

### Blob和Text类型
- blob和text被作为单独的对象进行存储。当blob和text值太大时，InnoDB会使用专门的"外部"存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值。
 
### 缓存表和汇总表

缓存表: 将主表的部分信息写入缓存表中，可以针对特殊查询，创建索引或者选择合适的存储引擎

汇总表: 保存从主表中聚合而来的结果数据

### 物化视图

物化视图实际上时预先计算并存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

### 加快alter table操作的数据

mysql执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这种方式在数据量很大，而且存在很多索引的情况下需要花费很长时间。

而且`alter table`操作将导致mysql服务中断。

比较常用的办法有两个
1. 在一台不提供服务的机器上执行alter操作，之后于提供服务的主库进行切换
2. 新建一张和原表相同的表，在该表上进行操作。之后通过重命名和删表交换两张表

## mysql高级特性

### 视图

pass

### 外键约束

外键约束保证数据的一致性，但也引入额外的性能消耗。
- 修改外键时都需要在另一张表中执行一次查找操作。虽然外键被强制使用索引，这也依赖于外键索引定义的是否合适。
- 当插入一行记录时，外键约束会让InnoDB检查对应的父表记录，这也就需要对父表进行加锁操作，来确保该记录在新记录插入期间不被删除
- 外键约束也可能成为瓶颈

### 触发器

触发器可以在执行insert、update、delete的时候执行一些特定操作。在mysql中可以指定是在sql语句执行前触发还是执行后触发。

触发器的限制
- 对于每个表的每个事件，最多只能定义一个触发器，即不能在`after insert`上定义两个触发器
- mysql只支持基于行的触发，即触发器始终是针对于一条记录的，而不是针对整个sql语句


### 查询缓存

- 缓存失效：查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。
- 缓存命中：将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包含一下因素，查询本身、当前要查询的数据库、客户端的协议的版本等。
  - 使用查询本身意味着mysql会区分大小写，空格，注释。
- 对查询缓存的存储和失效是一个加锁的排他操作，且这个锁是一个全局锁。如果查询缓存的数量很多时，由于缓存失效，可能导致服务僵死较长时间。
- 缓存未命中
  - 当查询语句中有一些不确定的函数时，则查询结果不会被缓存。例如NOW()、CURRENT_DATE()。
  - 查询没有被缓存过
  - 用于缓存的内存耗尽

查询缓存并不推荐在高并发的场景下使用，由于缓存失效可能导致服务僵死。如果打算使用mysql缓存查询，不要设置过大的内存，并且需要仔细评估缓存的收益和消耗。


