# mysql的高级特性

## 视图

pass

## 外键约束

外键约束保证数据的一致性，但也引入额外的性能消耗。
- 修改外键时都需要在另一张表中执行一次查找操作。虽然外键被强制使用索引，这也依赖于外键索引定义的是否合适。
- 当插入一行记录时，外键约束会让InnoDB检查对应的父表记录，这也就需要对父表进行加锁操作，来确保该记录在新记录插入期间不被删除
- 外键约束也可能成为瓶颈

## 触发器

触发器可以在执行insert、update、delete的时候执行一些特定操作。在mysql中可以指定是在sql语句执行前触发还是执行后触发。

触发器的限制
- 对于每个表的每个事件，最多只能定义一个触发器，即不能在`after insert`上定义两个触发器
- mysql只支持基于行的触发，即触发器始终是针对于一条记录的，而不是针对整个sql语句


## 查询缓存

- 缓存失效：查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。
- 缓存命中：将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包含一下因素，查询本身、当前要查询的数据库、客户端的协议的版本等。
  - 使用查询本身意味着mysql会区分大小写，空格，注释。
- 对查询缓存的存储和失效是一个加锁的排他操作，且这个锁是一个全局锁。如果查询缓存的数量很多时，由于缓存失效，可能导致服务僵死较长时间。
- 缓存未命中
  - 当查询语句中有一些不确定的函数时，则查询结果不会被缓存。例如NOW()、CURRENT_DATE()。
  - 查询没有被缓存过
  - 用于缓存的内存耗尽

查询缓存并不推荐在高并发的场景下使用，由于缓存失效可能导致服务僵死。如果打算使用mysql缓存查询，不要设置过大的内存，并且需要仔细评估缓存的收益和消耗。
