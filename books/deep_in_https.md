# 深入浅出https

## http遇到的问题
- 数据没有加密
- 无法验证身份
- 数据易被篡改

## 密码学

### 密码学的四个目标
1. 机密性
  - 通过加密算法保证
2. 完整性
  - 通过MAC（消息验证码）算法保证
3. 身份验证
  - 通过数字签名技术保证
4. 不可抵赖
  - 通过数字签名技术保证

### 密码学中的基本

#### 随机数

随机数中的特性
1. 效率
2. 随机性
  - 比如随机数生成器从0到9几个数字中挑选出4个数字，在生成的随机数中，0到9出现的次数是平均的。
3. 不可预测性
4. 不可重现性

#### hash算法

密码学中的hash算法的主要特性
- 相同的消息总能的到相同的摘要值，特定的hash算法，不管消息的长度是多少，最终的摘要值的长度是相同的
- 不管多长的消息，hash运算非常快速
- 通过摘要值很难逆向计算出原始消息，hash算法具备单向性，摘要值是不可逆的
- 原始消息一旦修改，即使是很轻微的修改，最终的摘要值也会发生变化
- 对于两个不同的消息，他们的摘要值很难相同

主要用途
1. 文件比较。常用的就是通过md5进行文件校验
2. 身份校验

安全的密码学hash算法
- 不同的消息对应的摘要值应该不同
  - TODO: 如何理解 *collision Resistance* & *pre-image Resistance* & *second pre-image Resistance*
    - https://crypto.stackexchange.com/questions/1173/what-are-preimage-resistance-and-collision-resistance-and-how-can-the-lack-ther
- 单向性：给出一个摘要值很难找出它的原始信息

hash算法分类
- md5
- SHA
- SHA-2
- SHA-3

### 对称加密算法

加密解密使用的是同一套密钥和算法

两种类型
- 块密码算法
- 流密码算法

### 消息验证码（message authentication code）

加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改。

加密算法虽然能够保证攻击者无法破解原文。但是无法避免攻击者修改部分数据。这样即使数据被破解，但是消息却已经被修改了。

AE加密模式
1. Encrypt-and-MAC(E&M): 分别对消息进行加密运算和MAC运行，之后将消息进行组合
2. MAC-then-Encrypt(MtE): 先进行MAC运行，之后将消息和MAC组合并一起加密
3. Encrypt-then-MAC(EtM): 先加密，再对密文进行MAC运算得到MAC值，最后组合数据。

AEAD加密模式

AEAD是AE模式的变体，AE模式需要使用者单独处理加密运算和MAC运算。AEAD则在底层组合了机密算法和MAC算法。
- CCM
- GCM
- ChaCha20-poly1305


### 非对称加密算法（公开密钥算法）

对称加密和非对称加密的区别
1. 功能不同。
  对称加密主要用于加密和解密。而非对称加密不仅可以用于加密解密，还可用于密钥协商、数字签名。
2. 密钥是一对。
  公钥加密，私钥解密。公钥可以给任何人，公钥仅能加密数据但无法解密数据，但私钥只能由密钥对的生成方保存。
3. 运行速度慢

> 著名的非对称加密方式是RSA算法。

密钥协商算法
- RSA密钥协商算法
  1. 客户端初始化连接服务器，服务器发送RSA密钥对的公钥给客户端
  2. 客户端生成一个随机值，这个值必须是随机的，不能被攻击者猜出，这个值就是会话密钥
  3. 客户端使用服务器RSA密钥对的公钥加密会话密钥，并发送给服务端，由于攻击者没有服务器的私钥，所以无法解密会话密钥
  4. 服务器用的他密钥解密出会话密钥
  5. 至此双方完成连接，接下来服务端和客户端可以使用对称加密算法和会话密钥加密解密数据。
- DH密钥协商算法

> 密钥协商算法，解决的是密钥的存储和安全传输问题。

### 数字签名

数字签名生成的流程
1. 发送者对消息计算摘要值
2. 发送者用私钥对摘要值进行签名得到签名值
3. 发送者将原始消息和签名值一同发送给接受者

数据签名验证流程
1. 接受者收到消息后，拆分出消息和消息签名值A
2. 接受者使用公钥对消息进行运算得到摘要值B
3. 接受者对摘要值B和签名值A进行比较，如果相同表示签名验证成功，否则就是验证失败

> 数字签名的标准算法DSS（digital signature standard）

> RSA加密算法是公钥加密，私钥解密；RSA签名算法是私钥签名，公钥验证签名。

### 算法安全性和性能

尽量先选择安全性高的算法，再在此基础上选择性能高的算法。


