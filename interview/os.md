# os

## 进程 & 线程 & 协程

进程: 系统内存分配的最小单位。

线程: cpu调度的最小单位（cpu只看得到线程）。一个进程可以包含多个线程。一个进程中所有的线程共享整个进程的资源。线程之间切换由操作系统控制。

协程: 一个线程可以包含多个协程，与线程相比占用的资源更少。由编程语言控制协程之间的切换。

## 多核、多线程、多协程

### 多核

cpu的核数是可以并行的线程的数量。由于超线程技术，实际上可以并行的线程通常是物理核数的两倍。

[超线程技术](???)

### 多线程

对于多核多线程，当总线程数少于核数，线程可以同时运行在不同的cpu上，实现并行。

单核多线程，不同的线程的执行会由cpu进行切换，此时不是并行而是并发。

基于单核多线程的模型，如果单核上的线程数量过多，将会导致cpu在上下文切换之间花费大量的时间，所以盲目的增加线程的数量，并不能让程序运行的更快。

### 多协程

多个协程共存在一个线程中，一个线程某一时刻只能在一个cpu上运行。所以单纯的增加协程的数量，可能会导致线程在上下文之间的切换花费大量时间。

协程仅适用于io密集型任务。

### cpu密集型任务
假设一个进程用来处理cpu密集任务。此时可以创建`cpu核数`个线程，这样就能充分的使用cpu资源。

### io密集型任务
假设一个进程用来处理io密集型任务。如果创建`cpu核素`个线程，由于io任务会被阻塞，所以无法充分利用每个cpu，此时就可以适当增加线程数。


### 死锁、死锁的产生条件和解决方法

- 互斥。某一资源同一时间只能被一个线程获取。
- 占有和等待。某一线程获取了部分资源，并且等待获取其他资源。
- 不可抢占。某一线程获取资源后，除非它本身释放资源，否则其他线程无法获取。
- 循环等待。存在一个循环等待链，上游请求的资源有下游占有。例如线程1和线程2都需要资源A和资源B。线程1获取了资源A，等待资源B。同时线程2获取了资源B，等待资源A。这样就形成了循环等待。

#### 解决死锁的常见方法

常用资源的有序分配，来破环死锁的形成条件。当不同的线程需要获取多个锁时，约定采用相同的顺序获取锁。

### 乐观锁和悲观锁

乐观锁: 假设在获取数据期间数据不会别其他线程修改，但在写入数据的事时候会检测是否被修改，如果数据被修改，则写入失败。

悲观锁: 假设在获取数据期间，数据可能被其他线程修改。当读写数据时会将数据锁住，在此期间其他线程无法修改该数据。
